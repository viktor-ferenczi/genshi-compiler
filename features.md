# Features and limitations #

## Abstract ##

Compiles Gensi XML templates into native source code for improved performance. The compiler supports most of Genshi's XML template constructs, see below for limitations. This approach provides most of the advantages of XML templating at the speed of text templates.

## Dependencies ##

Requires Python 2.6 and lxml:

  * [Python 2.6](http://www.python.org)
  * [lxml 2.2](http://lxml.de)

Newer versions should also work.

Python 3 support is in the plans.

## Directory layout ##

Subdirectories of the source distribution:

  * `genshi_compiler`: the Python package itself
  * `tests`: unit test suite
  * `benchmarks` benchmark scripts
  * `examples`: example scripts

Binary releases contain only the `genshi_compiler` package.

## Features ##

The compiled template is always an ASCII encoded source code of a program module in the target programming language of the compiler sublass you're using. The compiled module provides functions to render the template in a similar way as Genshi would, but without providing access to the token stream.

Each generated module contains a `render` function for rendering the whole template and additional functions for each py:def constructs defined. Template functions can also be called to generate template fragments.

This compiler is mostly useful to speed up the most frequently used parts of your templates by compiling them to native code, even to an extension module. Please note, that the compiler itself is not optimized for speed. It is still useful in cases where runtime compilation of a changing template is needed, but that is not its intended use case.

## Limitations ##

  * No support for features requiring the complete XML representation of the generated contents, most notably `py:match` is not supported.

  * No support for features requiring a template loader, so `xi:include` won't work. You can work around this by inserting a `<%python %>` processing instruction importing the compiled module corresponding to the template you wanted to include. Then you can simply invoke any of the compiled template functions from the imported module. Don't forget to enclose such calls into Markup() to prevent escaping of HTML generated by the compiled functions you are calling.

  * No support for stream filters, since the compiler is generating code for the direct formatting of textual output, so no token stream used as an intermediate representation. If you want to post-process the XML output, then you need to parse it, but this way it might not worth to compile the XML template in the first place...

  * Lenient variable lookup mode is not supported, since we generate actual source code depending on all the variables. Having to check for a special `UNDEFINED` value at runtime would lower the performance of the resulting code. Using such lenient variable lookups usually result in more fragile code and increased debugging time, so it is not a good practice in general.

  * No Undefined type. Please see above.

  * Default values for py:def parameters are evaluated at compilation time, so they can't refer to data in the template context.

  * `defined(...)` and `value_of(...)` template expressions are not supported, since they are not useful and not needed, see the previous item. You can use `locals()[...]` as a replacement for `value_of(...)` if you really need it.

  * `Markup()` is recognized only as the outermost call of template expression, so no way to concatenate multiple sub-expressions resulting in Markup objects in a single template expression. Use multiple subsequent expressions or enclose the whole expression in Markup() to prevent escaping of the expression's results. `Markup()` calls are compiled as code without escaping and do not result in any special call at runtime.

  * Calling template functions are only recognized as the outermost call inside template expressions, like in the case of `Markup()`. If you generate markup in a more complex way or have to call template functions from another module, then you need to enclose your whole template expression in `Markup()` to prevent escaping the result.

  * `py:attrs` cannot overwrite an attribute already listed for the given element in the template itself, such attributes will be doubled in the output, which might render the output markup invalid. We plan to detect this case, so such a situation might end up in a compile time exception in the future.

  * There can be more, please feel free to open tickets for them.

## Important notes ##

  * The compiler always defines the global method `render`, so there must be no Genshi function definition named `render`. You can modify the name of this function by overriding the `render_method_name` class attribute in your compiler subclass.

  * `py:def` defines global functions, so they are reusable separately just like the `render` function. They return unicode markup just like the `render` function, not Markup objects.

  * Python code can be embedded using the `<?python ... ?>` processing instruction. Common indentation is removed from the code block, so you can indent your block in a way it is the most readable for you. The compiler will indent the block to match its indentation level in the generated source code.

## Future plans ##

  * See the [Issue Tracker](http://code.google.com/p/genshi-compiler/issues/list) of the Google Code project.